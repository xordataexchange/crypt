{"name":"Crypt","tagline":"Store and retrieve encrypted configuration parameters from etcd or consul","body":"Watch Kelsey explain `crypt` in this quick 5 minute video:\r\n[![Crypt Demonstration Video](http://img.youtube.com/vi/zYpqqfuGwW8/0.jpg)](https://www.youtube.com/watch?v=zYpqqfuGwW8&list=UUpoYiy3kgOBELDOwIDEdnpg)\r\n\r\n\r\n**Fess up.**\r\nYou have passwords and usernames hard coded in your apps.  You have IP addresses checked in to your source code repository.  You have entire configuration files that were created by the developer who wrote the app and haven't been changed since she typed `git init`. \r\n\r\n# crypt\r\n`crypt` is here to lead you back to the Path of Enlightened Configuration.  Store encrypted configuration values in [etcd](https://github.com/coreos/etcd) or [consul](http://www.consul.io/) using a command line application.\r\n\r\nDecrypt them before starting your application using a wrapper script and the handy CLI tool, or inside the app using the `crypt/config` library.\r\n\r\n## Standards\r\n`crypt` is built on time-tested standards like OpenPGP, base64, and gzip.  Your data is encrypted using public key encryption, and can only be decrypted by when the private key is available.  After compression, it is encrypted, and base64 encoded so it can be stored in your key/value store of choice.  We support etcd and consul out of the box, but adding other storage tools is a trivial task, thanks to Go's interfaces.\r\n\r\n## How it works\r\n`crypt` compresses, encrypts, then encodes your value for storage, then puts it at the location you specify on your key/value store.  To encrypt, you'll need access to one or more public keys.\r\n\r\nIn order to decrypt a value, your application will need access to the private key.  We recommend putting the private key on the server and protecting it with standard host level security.  Then make sure your application runs under the context of a named user on your system, and that user is the only user with access to the private key(ring).  If you're running within Docker, just mount a volume from the directory with the private key.  ** Don't put your private key in your Docker container.  Seriously.  Just don't. **\r\n\r\n## Usage\r\nYou can use crypt as a command line tool or as a configuration library:\r\n\r\n* [crypt cli](https://github.com/xordataexchange/crypt/tree/master/bin/crypt)\r\n* [crypt/config](https://github.com/xordataexchange/crypt/tree/master/config)\r\n\r\n## Generating gpg keys and keyrings\r\n\r\nThe crypt cli and config package require gpg keyrings.  ** Read about them [here](https://www.gnupg.org/gph/en/manual.html) before you blindly follow a tutorial written by someone you don't know and shouldn't trust. **\r\n\r\n### Create a key and keyring from a batch file\r\n\r\n```\r\nvim myapp.batch\r\n```\r\n\r\n```\r\n%echo Generating a configuration OpenPGP key\r\nKey-Type: default\r\nSubkey-Type: default\r\nName-Real: myapp\r\nName-Comment: myapp configuration key\r\nName-Email: app@example.com\r\nExpire-Date: 0\r\n%pubring .pubring.gpg\r\n%secring .secring.gpg\r\n%commit\r\n%echo done\r\n```\r\n\r\nRun the following command:\r\n\r\n```\r\ngpg2 --batch --armor --gen-key myapp.batch\r\n```\r\n\r\nYou should now have two keyrings, `.pubring.gpg` which contains the public keys, and `.secring.gpg` which contains the private keys.  This is a place where you can get fancy -- create different keyrings for different environments.  Make one for your production environment that the developers don't have access to.  Remember [separation of duties](http://www.sans.edu/research/security-laboratory/article/it-separation-duties) to keep your data safe.\r\n\r\n> Note the private key is not protected by a passphrase.\r\n\r\n## Create a configuration key\r\nYou can encrypt a single value, or an entire configuration file.  `crypt` will read the contents of the file you specify and encrypt it, then store it in your data store.\r\n\r\n** Keep your configuration values atomic ***\r\nDon't set the database username in one key and the password in another key.  Most k/v stores don't support transactions, so you might get the change to one, but not the other.  Instead, keep related configurations together in a single file, and write/read them atomically.\r\n\r\nHere's how to encrypt a file called `config.json` and store it at /myapp/config in etcd:\r\n```\r\ncrypt set -backend etcd -endpoint http://127.0.0.1:4001 -keyring pubring.gpg /myapp/config config.json \r\n```\r\nTo retrieve it on the command line:\r\n```\r\ncrypt get -backend etcd -endpoint http://127.0.0.1:4001 -keyring pubring.gpg > config.json\r\n```\r\n\r\nOr inside your application:\r\n\r\n```\r\npackage main\r\n\r\nimport (\r\n    \"fmt\"\r\n    \"log\"\r\n    \"os\"\r\n\r\n    \"github.com/xordataexchange/crypt/config\"\r\n)\r\n\r\nvar (\r\n    key           = \"/myapp/config\"\r\n    secretKeyring = \".secring.gpg\"\r\n)\r\n\r\nfunc main() {\r\n    kr, err := os.Open(secretKeyring)\r\n    if err != nil {\r\n        log.Fatal(err)\r\n    }\r\n    defer kr.Close()\r\n    machines := []string{\"http://127.0.0.1:4001\"}\r\n    cm, err := config.NewEtcdConfigManager(machines, kr)\r\n    if err != nil {\r\n        log.Fatal(err)\r\n    }\r\n    value, err := cm.Get(key)\r\n    if err != nil {\r\n        log.Fatal(err)\r\n    }\r\n    // now use the data\r\n    //fmt.Printf(\"%s\\n\", value)\r\n    // var config MyConfigStruct\r\n    // err := json.Unmarshal(value, &config)\r\n}\r\n```\r\n\r\n### Security Note\r\nRemember your data is only as secure as your private key.  Do some research and figure out a safe and secure way to keep your key away.\r\n\r\n## Contributing\r\nWe'll happily accept contributions for new storage backends (mongodb?) and link to library implementations in other languages.  Fork, and send a clean PR in a new branch.  \r\n\r\n## License\r\nThe MIT License (MIT)\r\n\r\nCopyright (c) 2014 XOR Data Exchange, Inc.\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.","google":"UA-55882461-1","note":"Don't delete this file! It's used internally to help with page regeneration."}